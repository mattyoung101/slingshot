/*
 * Copyright (c) 2023 Matt Young.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

package slingshot.completion

import org.eclipse.lsp4j.CompletionItem
import org.eclipse.lsp4j.CompletionItemKind
import org.tinylog.kotlin.Logger
import slingshot.parsing.CompletionTypes
import slingshot.parsing.SvDocument


/**
 * Using a list of [CompletionTypes] recommendations generated by CursorParseTreeVisitor, and a
 * [SvDocument], generate the actual completion items by analysing the SvDocument instance.
 */
class CompletionSelector(private val completion: CompletionResult) {
    private fun generateVariableSameModule(): List<CompletionItem> {
        completion.activeModule ?: return listOf()
        return completion.document.getModuleByName(completion.activeModule).variables.map {
            CompletionItem(it.name).apply { kind = CompletionItemKind.Variable }
        }
    }

    private fun generatePortSameModule(): List<CompletionItem> {
        completion.activeModule ?: return listOf()
        return completion.document.getModuleByName(completion.activeModule).ports.map {
            CompletionItem(it.name).apply { kind = CompletionItemKind.Field }
        }
    }

    private fun generateModule(): List<CompletionItem> {
        return completion.document.modules.map {
            CompletionItem(it.name).apply { kind = CompletionItemKind.Module }
        }
    }

    private fun generateEdge(): List<CompletionItem> {
        val posedge = CompletionItem("posedge").apply { kind = CompletionItemKind.Event }
        val negedge = CompletionItem("negedge").apply { kind = CompletionItemKind.Event }
        return listOf(posedge, negedge)
    }

    private fun generateLogic(): List<CompletionItem> {
        val logic = CompletionItem("logic").apply { kind = CompletionItemKind.Keyword }
        // maybe add wire, reg if people ask for verilog support
        return listOf(logic)
    }

    private fun generateEnum(): List<CompletionItem> {
        return completion.document.enums.map {
            CompletionItem(it.name).apply { kind = CompletionItemKind.Enum }
        }
    }

    // this currently generates enum values for all enums in the document
    private fun generateEnumValue(): List<CompletionItem> {
        return completion.document.enums.flatMap { it.enumValues }.map {
            CompletionItem(it.name).apply { kind = CompletionItemKind.EnumMember }
        }
    }

    /**
     * Generates completion items to return to the user based on the provided [completion]
     */
    fun generate(): List<CompletionItem> {
        val out = mutableListOf<CompletionItem>()

        for (rec in completion.recommendations) {
            when (rec) {
                CompletionTypes.VariableSameModule -> out.addAll(generateVariableSameModule())
                CompletionTypes.PortSameModule -> out.addAll(generatePortSameModule())
                CompletionTypes.Edge -> out.addAll(generateEdge())
                CompletionTypes.Logic -> out.addAll(generateLogic())
                CompletionTypes.Module -> out.addAll(generateModule())
                CompletionTypes.Enum -> out.addAll(generateEnum())
                CompletionTypes.EnumValue -> out.addAll(generateEnumValue())
                else -> Logger.warn("Unhandled recommendation type: $rec")
            }
        }

        return out
    }
}